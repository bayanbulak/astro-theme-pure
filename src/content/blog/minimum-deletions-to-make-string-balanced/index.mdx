---
title: 1653. 使字符串平衡的最小删除次数
publishDate: 2023-03-06
description: '应用题目条件中的平方信息，通过开平方把时间复杂度降低半个维度'
tags:
  - stack
  - string
  - dynamic planing
  - greedy
  - medium
language: '中文'
---

import { Card } from 'astro-pure/user'

## 题目
<Card
  as='a'
  href='#card'
  heading='1653. Minimum Deletions to Make String Balanced'
  subheading='Medium, Stack, Greedy, Dynamic Planing'
  href='https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/description/'
>
</Card>

这是一道非常经典的**字符串处理**题目，考察的核心是如何在**动态规划 (DP)** 和 **枚举 (Enumeration)** 之间找到最优解。

**题目大意**：
给你一个只包含字符 `'a'` 和 `'b'` 的字符串 `s`。你需要删除最少数量的字符，使得 `s` 变为 **“平衡”** 字符串。
**平衡**的定义是：如果字符串中不存在下标对  满足  且  同时 。
换句话说，**所有的 'a' 都必须在所有的 'b' 之前**。

---

## 核心思路

这就意味着最终的字符串长这样：`aaaa...abbbb...b`。
我们可以通过以下三种思路来解决这个问题，层层递进：

### 1. 思路一：枚举分割点 (前后缀统计)

最直观的想法是，既然最终结果一定是 `a...ab...b` 的形式，那么一定存在一个 **“分割点”**。

* 分割点左边全是 `'a'`（意味着左边的 `'b'` 都要删掉）。
* 分割点右边全是 `'b'`（意味着右边的 `'a'` 都要删掉）。

我们可以遍历每一个可能的分割位置（从字符串开头之前到结尾之后），计算删除代价，取最小值。

* **步骤**：
  1. 预处理计算整个字符串中 `'a'` 的总数。
  2. 遍历字符串：
  * 维护 `count_b_left`：当前位置左边有多少个 `'b'` (需要删除)。
  * 维护 `count_a_right`：当前位置右边有多少个 `'a'` (需要删除)。
  * 当前的删除次数 = `count_b_left` + `count_a_right`。

  3. 更新最小值。

**复杂度**：时间 $O(N)$ ，空间 $O(1)$ (只需要几个变量维护计数)。

### 2. 思路二：动态规划 (Dynamic Programming)

我们可以定义状态来做决策。当我们遍历到第 $i$ 个字符时：

* **定义状态**： 表示前  个字符变为平衡字符串所需的最少删除次数。
* **状态转移**：
  * **如果 $S[i] == 'b'$**：
  * 在这个 'b' 之前如果已经是平衡的，加上这个 'b' 依然是平衡的（因为 'b' 在最后）。
  * 所以不需要删除，代价不变： $dp[i] = dp[i - 1]$。


* **如果 $S[i] == 'a'$**：
  * 这就麻烦了，'a' 不能出现在 'b' 后面。我们有两个选择：
    1. **删除当前的 'a'**：代价是前一个状态的代价 + 1，即 。
    2. **保留当前的 'a'**：如果保留这个 'a'，意味着它前面不能有任何 'b'。所以我们需要删除前面所有的 'b'。代价是 `count_b` (目前为止遇到的 'b' 的数量)。

  * 取两者的最小值：。

**空间优化**：
观察发现 $dp[i]$ 只和 $dp[i-1]$ 有关，因此可以使用一个变量 `dp` 来滚动更新，不需要数组。

### 3. 思路三：栈/贪心 (Stack/Greedy) - **最推荐**

这个思路其实是 DP 的另一种理解方式，更符合直觉。
我们可以把字符串看作是一个消除游戏。只要出现 `...ba...` 这样的模式，就是不合法的。

* 我们需要消除成对的 `ba`。
* 维护一个 `count_b` 记录当前还没被消除的 'b' 的数量。
* 遍历字符：
  * 遇到 `'b'`：`count_b` 加 1。
  * 遇到 `'a'`：
    * 如果 `count_b > 0`（说明前面有 'b'，构成了 `ba` 冲突）：我们需要删除一次。是删 'b' 还是删 'a'？其实不重要，重要的是我们消耗了一次“删除权”来解决这个冲突。我们可以理解为删除了当前的 'a' 或者抵消了前面的一个 'b'。
    * 结果 `ans` 加 1，同时 `count_b` 减 1（贪心地抵消掉最靠近的一个 'b'）。


---

## 代码实现 (Java)

这里提供 **空间优化的 DP / 贪心** 写法，这是面试中最优的解法。

```java
class Solution {
    public int minimumDeletions(String s) {
        int cntB = 0;
        int dp = 0; // 代表最少删除次数
        
        for (char c : s.toCharArray()) {
            if (c == 'b') {
                cntB++;
            } else {
                // c == 'a'
                // Math.min(删除当前a的代价, 删除前面所有b的代价)
                // 删除当前a: dp + 1
                // 保留当前a (即删除前面所有b): cntB
                dp = Math.min(dp + 1, cntB);
            }
        }
        
        return dp;
    }
}

```

---

## 复杂度分析

* **时间复杂度**: $O(N)$ 
  * 我们只需要遍历一次字符串。


* **空间复杂度**: $O(1)$
  * 只使用了 `cntB` 和 `dp` 两个整数变量，没有使用额外的数组空间。



## 总结与技巧

1. **识别模式**：凡是涉及到 "使得字符串满足某种顺序 (如 a 在 b 前)" 的题目，通常都可以转化为 **枚举分割点** 或者 **动态规划**。
2. **DP 的本质**：这道题 DP 的核心在于遇到冲突 (`...ba...`) 时的决策：是牺牲当前的 'a' (为了保全前面的结构)，还是牺牲前面所有的 'b' (为了让这个 'a' 合法)。
3. **栈与计数**：如果题目只需要计算数量而不需要具体的修改后字符串，用计数变量代替栈结构（思路三）通常能将空间优化到 。