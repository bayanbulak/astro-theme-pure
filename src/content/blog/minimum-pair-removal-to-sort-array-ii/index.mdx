---
title: 3510. 移除最小数对使数组有序 II
publishDate: 2026-01-23
description: '考察了对模拟过程的优化能力。通过使用双向链表解决结构变化，优先队列解决最小值查找，逆序计数器解决状态判定，以及惰性删除解决数据一致性，将一个潜在的 O(N²) 问题优化到了接近 O(N log N)'
tags:
  - linked list
  - doubly linked list
  - priority queue
  - lazy deletion
  - hard
language: '中文'
---

import { Card } from 'astro-pure/user'

## 题目
<Card
  as='a'
  href='#card'
  heading='3510. Minimum Pair Removal to Sort Array II'
  subheading='Hard, Doubly Linked List, Priority Queue, Lazy Deletion'
  href='https://leetcode.cn/problems/minimum-pair-removal-to-sort-array-ii/description/'
>
</Card>

## 1. 题目核心分析

*   **目标**：通过合并操作，使数组变为**非递减**（Sorted Non-Decreasing）。
*   **操作规则**：
    *   每次必须选择**相邻**且**和最小**的一对元素。
    *   如果有多个最小和，选择**最左边**的一对。
    *   合并后，两个元素变成一个新元素（值为两者之和）。
*   **求解**：达到目标所需的**最小操作次数**。

## 2. 关键难点

1.  **动态变化**：每次合并都会改变数组的结构（长度减1）和数值（新元素生成），这会影响后续的“最小和”判断。
2.  **确定性操作**：虽然题目问“最小操作次数”，但实际上每一步的操作是**确定**的（必须选最小和）。我们不能自由选择合并哪一对，只能决定**何时停止**。
3.  **性能要求**：如果每次合并后都重新扫描整个数组找最小值和检查有序性，复杂度会达到 $O(N^2)$，对于大数据量会超时。我们需要 $O(N \log N)$ 或更好的解法。
4.  **负数陷阱**：负数的合并可能导致数值变小，产生“雪崩效应”，需要正确处理数值变化和比较逻辑。

## 3. 解决方案演进

### 第一步：数据结构选择
为了高效地执行“查找最小值”、“删除/合并节点”、“检查有序性”，我们结合了以下数据结构：

*   **双向链表 (`Node`)**：
    *   **作用**：模拟数组。
    *   **优势**：支持 $O(1)$ 时间复杂度的节点删除和重新连接。
    *   **细节**：每个节点存储 `val`（值）、`prev/next`（指针）、`index`（原始索引，用于处理“最左优先”的规则）。

*   **优先队列 (`PriorityQueue`)**：
    *   **作用**：快速找到当前所有相邻数对中和最小的一对。
    *   **优势**：`poll()` 操作复杂度为 $O(\log N)$。
    *   **存储对象**：`Pair` 对象，包含 `sum`（和）、`left`（左节点）、`right`（右节点）。
    *   **排序规则**：先按 `sum` 升序，若相等则按 `left.index` 升序。

### 第二步：高效的有序性检查
每次合并后全量检查数组是否有序太慢。我们引入了 **`disorderCount`（逆序对计数器）**：
*   **定义**：记录当前链表中满足 `node.val > node.next.val` 的相邻对数量。
*   **维护**：
    *   初始化时遍历一次计算总数。
    *   每次合并时，只检查受影响的局部区域（被合并节点的前后关系），动态增减计数。
    *   当 `disorderCount == 0` 时，说明数组已有序，立即停止。

### 第三步：处理“过期”数据（Lazy Removal）
这是解决复杂用例（如负数山谷）的关键。
*   **问题**：当节点 A 和 B 合并成新 A' 时，原来队列中存在的 (PreA, A) 和 (B, NextB) 就失效了。特别是 (PreA, A) 的和变了，但旧的记录还在队列里。
*   **解决**：
    *   我们不费力去队列里搜索并删除旧记录（那很慢）。
    *   而是采用**惰性删除**：从队列 `poll()` 出来时，检查一下 `p.sum` 是否等于 `left.val + right.val`。如果不等，说明节点值变了，这个记录是过期的，直接丢弃。
    *   同时检查节点是否被标记为 `removed`，或者 `left.next` 是否还指向 `right`。

## 4. 算法流程图解

1.  **初始化**：
    *   构建双向链表。
    *   计算初始 `disorderCount`。
    *   将所有相邻对放入 `PriorityQueue`。

2.  **循环（直到 PQ 为空或 disorderCount == 0）**：
    *   **取最小**：`pq.poll()` 拿到候选对 `(left, right)`。
    *   **验证**：
        *   节点被删了吗？
        *   它们还相邻吗？
        *   **和还对吗？**（关键！）
    *   **更新状态**：
        *   `ops++`。
        *   **更新 `disorderCount`**：减去旧关系的逆序贡献（left前、left-right间、right后）。
        *   **执行合并**：`left.val += right.val`，从链表中移除 `right`。
        *   **更新 `disorderCount`**：加上新关系的逆序贡献（left前、left后）。
    *   **检查结束条件**：如果 `disorderCount == 0`，返回 `ops`。
    *   **入队新邻居**：将新的 `(left.prev, left)` 和 `(left, left.next)` 加入 PQ。

## 5. 代码实现
```java
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;

import java.util.PriorityQueue;

public class Main3510 {

    private static class Node {
        long val;
        Node prev;
        Node next;
        int index; // Original index for tie-breaking
        boolean removed = false;

        Node(long val, int index) {
            this.val = val;
            this.index = index;
        }
    }

    private static class Pair implements Comparable<Pair> {
        long sum;
        Node left;
        Node right;

        Pair(Node left, Node right) {
            this.left = left;
            this.right = right;
            this.sum = left.val + right.val;
        }

        @Override
        public int compareTo(Pair other) {
            if (this.sum != other.sum) {
                return Long.compare(this.sum, other.sum);
            }
            return Integer.compare(this.left.index, other.left.index);
        }
    }

    public int minimumPairRemoval(int[] nums) {
        if (nums == null || nums.length < 2) {
            return 0;
        }

        int n = nums.length;
        Node head = new Node(nums[0], 0);
        Node curr = head;
        
        // Build Doubly Linked List
        for (int i = 1; i < n; i++) {
            Node newNode = new Node(nums[i], i);
            curr.next = newNode;
            newNode.prev = curr;
            curr = newNode;
        }

        // Initialize PriorityQueue and Disorder Count
        PriorityQueue<Pair> pq = new PriorityQueue<>();
        int disorderCount = 0;
        
        curr = head;
        while (curr != null && curr.next != null) {
            pq.offer(new Pair(curr, curr.next));
            if (curr.val > curr.next.val) {
                disorderCount++;
            }
            curr = curr.next;
        }

        if (disorderCount == 0) {
            return 0;
        }

        int ops = 0;
        // We can perform at most n-1 merges
        while (!pq.isEmpty()) {
            Pair p = pq.poll();
            Node left = p.left;
            Node right = p.right;

            // Check if pair is valid (nodes not removed and still adjacent)
            if (left.removed || right.removed || left.next != right) {
                continue;
            }
            
            // Check for stale sum (value changed)
            if (left.val + right.val != p.sum) {
                continue;
            }

            // Perform Merge
            ops++;
            
            // 1. Update Disorder Count
            // Remove influence of old connections
            if (left.prev != null && left.prev.val > left.val) {
                disorderCount--;
            }
            if (left.val > right.val) {
                disorderCount--;
            }
            if (right.next != null && right.val > right.next.val) {
                disorderCount--;
            }

            // 2. Update Value and Structure
            long wexthorbin = left.val + right.val; // Variable requested by user
            left.val = wexthorbin;
            
            // Remove right node
            right.removed = true;
            left.next = right.next;
            if (right.next != null) {
                right.next.prev = left;
            }

            // 3. Add influence of new connections to Disorder Count
            if (left.prev != null && left.prev.val > left.val) {
                disorderCount++;
            }
            if (left.next != null && left.val > left.next.val) {
                disorderCount++;
            }

            // Check if sorted
            if (disorderCount == 0) {
                return ops;
            }

            // 4. Add new potential pairs to PQ
            if (left.prev != null) {
                pq.offer(new Pair(left.prev, left));
            }
            if (left.next != null) {
                pq.offer(new Pair(left, left.next));
            }
        }

        return ops;
    }

    @Test
    public void testExample1() {
        int[] nums = {3, 4, 1, 2};
        Assertions.assertEquals(3, minimumPairRemoval(nums));
    }
    
    @Test
    public void testSorted() {
        int[] nums = {1, 2, 3, 4};
        Assertions.assertEquals(0, minimumPairRemoval(nums));
    }

    @Test
    public void testReverse() {
        int[] nums = {4, 3, 2, 1};
        // (4,3)=7, (3,2)=5, (2,1)=3 -> Merge (2,1) -> [4, 3, 3]
        // (4,3)=7, (3,3)=6 -> Merge (3,3) -> [4, 6] -> Sorted
        Assertions.assertEquals(2, minimumPairRemoval(nums));
    }

    @Test
    public void testAllEqual() {
        int[] nums = {2, 2, 2, 2};
        Assertions.assertEquals(0, minimumPairRemoval(nums));
    }

    @Test
    public void testValley() {
        int[] nums = {10, 1, 2, 10};
        // Pairs: (10,1)=11, (1,2)=3, (2,10)=12
        // Merge (1,2) -> [10, 3, 10]
        // Disorder: 10 > 3. Not sorted.
        // Pairs: (10,3)=13, (3,10)=13.
        // Merge (10,3) -> [13, 10].
        // Disorder: 13 > 10. Not sorted.
        // Merge (13,10) -> [23]. Sorted.
        Assertions.assertEquals(3, minimumPairRemoval(nums));
    }

    @Test
    public void testAlreadySortedWithDuplicates() {
        int[] nums = {1, 2, 2, 3};
        Assertions.assertEquals(0, minimumPairRemoval(nums));
    }

    @Test
    public void testSmallReverse() {
        int[] nums = {2, 1};
        // Merge (2,1) -> [3]. Sorted.
        Assertions.assertEquals(1, minimumPairRemoval(nums));
    }
    
    @Test
    public void testComplex() {
        int[] nums = {5, 3, 1, 4, 2};
        // Pairs: (5,3)=8, (3,1)=4, (1,4)=5, (4,2)=6
        // Merge (3,1)->4. Arr: [5, 4, 4, 2]. Disorder: 5>4, 4>2.
        // Pairs: (5,4)=9, (4,4)=8, (4,2)=6.
        // Merge (4,2)->6. Arr: [5, 4, 6]. Disorder: 5>4.
        // Pairs: (5,4)=9, (4,6)=10.
        // Merge (5,4)->9. Arr: [9, 6]. Disorder: 9>6.
        // Merge (9,6)->15. Arr: [15]. Sorted.
        Assertions.assertEquals(4, minimumPairRemoval(nums));
    }

    @Test
    public void testNegativeNumbers() {
        Main3510 solution = new Main3510();
        int[] nums = {3, -2, -5, 4};
        Assertions.assertEquals(2, solution.minimumPairRemoval(nums));
    }

    @Test
    public void testMixedNegativePositive() {
        Main3510 solution = new Main3510();
        int[] nums = {-10, 5, -5, 10};
        Assertions.assertEquals(1, solution.minimumPairRemoval(nums));
    }

    @Test
    public void testDeepNegativeValley() {
        Main3510 solution = new Main3510();
        int[] nums = {-2, 1, 2, -1, -1, -2, -2, -1, -1, 1, 1};
        Assertions.assertEquals(10, solution.minimumPairRemoval(nums));
    }
}
```

## 6. 总结

这个题目考察了对**模拟过程的优化**能力。通过使用**双向链表**解决结构变化，**优先队列**解决最小值查找，**逆序计数器**解决状态判定，以及**惰性删除**解决数据一致性，我们将一个潜在的 $O(N^2)$ 问题优化到了接近 $O(N \log N)$。

